#!/usr/bin/env python3
"""
Project Reconstruction Tool

This script reverse engineers a project from the output text file generated by print_project.py.
It parses the file structure and content, then recreates all files in their original locations.

Usage:
    python reconstruct_project.py <output_file.txt> [--output-dir OUTPUT_DIR] [--dry-run]

Options:
    --output-dir DIR    Directory to reconstruct the project (default: current directory)
    --dry-run          Show what would be created without actually creating files
    --overwrite        Overwrite existing files (default: skip existing files)
    --verbose          Show detailed progress information
"""

import argparse
import os
import re
import sys
from pathlib import Path


def parse_output_file(file_path):
    """
    Parse the output file and extract project structure and file contents.
    
    Args:
        file_path: Path to the output text file
        
    Returns:
        dict: Dictionary with 'metadata' and 'files' (list of {path, content})
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Extract metadata from header
    metadata = {}
    header_match = re.search(r'# Project: (.+?)\n# Date: (.+?)\n# Directory: (.+?)\n', content)
    if header_match:
        metadata['project_name'] = header_match.group(1)
        metadata['date'] = header_match.group(2)
        metadata['original_directory'] = header_match.group(3)
    
    # Find the FILE CONTENTS section
    file_contents_start = content.find('FILE CONTENTS')
    if file_contents_start == -1:
        raise ValueError("Could not find 'FILE CONTENTS' section in the output file")
    
    file_section = content[file_contents_start:]
    
    # Pattern to match file blocks: === path === followed by code block
    file_pattern = r'=== (.+?) ===\n```\n(.*?)```'
    
    files = []
    for match in re.finditer(file_pattern, file_section, re.DOTALL):
        file_path = match.group(1).strip()
        file_content = match.group(2)
        
        # Remove line numbers (format: "   1 | content" or "   X | content")
        lines = file_content.split('\n')
        cleaned_lines = []
        for line in lines:
            # Match pattern: spaces + number + " | " + content
            line_match = re.match(r'^\s*\d+\s+\|\s?(.*)$', line)
            if line_match:
                cleaned_lines.append(line_match.group(1))
            else:
                # If line doesn't match pattern, keep it as is (might be empty or special)
                cleaned_lines.append(line)
        
        # Join lines back, but preserve the original line structure
        # Handle the case where last line might be empty
        file_text = '\n'.join(cleaned_lines)
        
        files.append({
            'path': file_path,
            'content': file_text
        })
    
    return {
        'metadata': metadata,
        'files': files
    }


def reconstruct_project(parsed_data, output_dir, overwrite=False, dry_run=False, verbose=False):
    """
    Reconstruct the project from parsed data.
    
    Args:
        parsed_data: Dictionary with 'metadata' and 'files'
        output_dir: Directory to create the project
        overwrite: Whether to overwrite existing files
        dry_run: If True, only show what would be created
        verbose: Show detailed progress
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    files_created = 0
    files_skipped = 0
    files_overwritten = 0
    
    if verbose or dry_run:
        print(f"\n{'DRY RUN: ' if dry_run else ''}Reconstructing project to: {output_path}")
        print(f"Found {len(parsed_data['files'])} files to process\n")
    
    for file_info in parsed_data['files']:
        file_path = file_info['path']
        file_content = file_info['content']
        
        # Create full path
        full_path = output_path / file_path
        
        # Check if file exists
        if full_path.exists() and not overwrite:
            if verbose:
                print(f"â­ï¸  Skipping (exists): {file_path}")
            files_skipped += 1
            continue
        
        if full_path.exists() and overwrite:
            if verbose:
                print(f"ðŸ”„ Overwriting: {file_path}")
            files_overwritten += 1
        elif verbose:
            print(f"ðŸ“ Creating: {file_path}")
        
        if not dry_run:
            # Create parent directories
            full_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write file content
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(file_content)
        
        files_created += 1
    
    # Summary
    print(f"\n{'=' * 60}")
    print(f"{'DRY RUN SUMMARY' if dry_run else 'RECONSTRUCTION SUMMARY'}")
    print(f"{'=' * 60}")
    print(f"Files to create: {files_created}")
    if files_skipped > 0:
        print(f"Files skipped (exist): {files_skipped}")
    if files_overwritten > 0:
        print(f"Files overwritten: {files_overwritten}")
    print(f"Total files processed: {len(parsed_data['files'])}")
    
    if not dry_run:
        print(f"\nâœ… Project reconstructed successfully in: {output_path}")
    else:
        print(f"\nðŸ’¡ Run without --dry-run to actually create the files")
    
    return {
        'created': files_created,
        'skipped': files_skipped,
        'overwritten': files_overwritten,
        'total': len(parsed_data['files'])
    }


def main():
    """Main function."""
    parser = argparse.ArgumentParser(
        description='Reverse engineer a project from print_project.py output file',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Dry run to see what would be created
  python reconstruct_project.py output/bedrock_api_project.txt --dry-run
  
  # Reconstruct to current directory
  python reconstruct_project.py output/bedrock_api_project.txt
  
  # Reconstruct to specific directory
  python reconstruct_project.py output/bedrock_api_project.txt --output-dir ./reconstructed_project
  
  # Overwrite existing files
  python reconstruct_project.py output/bedrock_api_project.txt --overwrite --verbose
        """
    )
    
    parser.add_argument(
        'input_file',
        help='Path to the output text file from print_project.py'
    )
    
    parser.add_argument(
        '--output-dir',
        default='.',
        help='Directory to reconstruct the project (default: current directory)'
    )
    
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be created without actually creating files'
    )
    
    parser.add_argument(
        '--overwrite',
        action='store_true',
        help='Overwrite existing files (default: skip existing files)'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show detailed progress information'
    )
    
    args = parser.parse_args()
    
    # Validate input file
    if not os.path.exists(args.input_file):
        print(f"Error: Input file not found: {args.input_file}")
        return 1
    
    # Parse the output file
    try:
        if args.verbose:
            print(f"Parsing output file: {args.input_file}")
        parsed_data = parse_output_file(args.input_file)
        
        if args.verbose:
            print(f"Found project: {parsed_data['metadata'].get('project_name', 'Unknown')}")
            print(f"Original directory: {parsed_data['metadata'].get('original_directory', 'Unknown')}")
            print(f"Date: {parsed_data['metadata'].get('date', 'Unknown')}")
        
    except Exception as e:
        print(f"Error parsing output file: {e}")
        return 1
    
    # Reconstruct the project
    try:
        stats = reconstruct_project(
            parsed_data,
            args.output_dir,
            overwrite=args.overwrite,
            dry_run=args.dry_run,
            verbose=args.verbose
        )
        return 0
    except Exception as e:
        print(f"Error reconstructing project: {e}")
        import traceback
        if args.verbose:
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())